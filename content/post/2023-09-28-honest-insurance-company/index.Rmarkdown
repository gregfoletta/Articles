---
title: Honest Insurance Company
author: Greg Foletta
date: '2023-09-28'
slug: []
categories: [R Bayesian]
tags: []
---

```{r include=FALSE}
library(tidyverse)
library(tidybayes)
library(RSelenium)
library(rvest)
library(glue)
library(cmdstanr)
library(here)
library(tidybayes)
library(bayesplot)
library(gganimate)
library(scales)
```

Last month my car - a Toyota Kluger - was run into while parked in front of my house. Luckily no one was injured and while annoying, the person had insurance (coincidently with the same company as my). The insurance company came back and determined that the car had been written off and I would be paid out the market value of the car. But what is the market value? How could I keep the insurance company honest and make sure I wasn't getting stiffed?

In this post I'll go through the process I used to keep the insurance company honest. There's data acquisition and visiualisation of the current market, then modelling of the market price. 

# Data Aquisition

The first step was to acquire some data on the current market for Toyota Klugers. I used [carsales.com.au](https://www.carsales.com.au/cars/used/toyota/kluger/) as my source. The Carsales site requires Javascript to render, so simply requesting the pages wasn't going to work. Instead we need to render the page in a browser. To do this I used a docker instance of the webdriver [Selenium](https://www.selenium.dev/), interfacing into this with the R package [RSelenium](https://github.com/ropensci/RSelenium). This allows us to browse to the site from a 'remotely controller' browser, Javascript and all, and retrieve the information we need.

First up, we connect to the docker instance, setting the page load strategy to eager so that it will return when the initial HTML is loaded and not wait for stylesheets, images, etc.

```{sh eval=FALSE, include=FALSE}
# Stop running containers
if [ $(docker container ls -q --filter name=rsel --all) ]
then
        docker container stop rsel
        docker container rm rsel
fi
```

```{sh eval=FALSE, include=FALSE }
docker run -d -p 4444:4444 --name rsel selenium/standalone-firefox:latest
```

```{r eval = FALSE, echo=TRUE, results = 'hide'}
rs <- remoteDriver(remoteServerAddr = '172.17.0.2', port = 4444L)
rs$extraCapabilities$pageLoadStrategy <- "eager"
rs$open()
```

Each page of Klugers for sale is determined by an offset of 12. We generate the offsets (12, 24, 36 etc) and the URIs based on these offsets. We then navigate to each page, reading the source, and parsing into a structuered XML document     .

```{r eval = FALSE}
kluger_source <-
    tibble(
        # Generate offsets
        offset = 12 * c(0:100),
        # Create URIs based on offsets
        uri = glue("https://www.carsales.com.au/cars/used/toyota/kluger/?offset={offset}")
    ) |> 
    mutate(
        # Naviate to each URI, read and parse the source
        source = map(uri, ~{ 
            rs$navigate(uri)
            rs$getPageSource() |> pluck(1) |> read_html()
        } )
    )
```

# Data Extractiion

We've got our raw source, we now need to pull out the data we need from it. First a little helper function which finds an element based on its XPath, and pulls out the text of that element.

```{r}
# XPath helper function, xpt short for xpath_text
xpt <- function(html, xpath) {
    html_elements(html, xpath = xpath) |> 
    html_text()
}
```

Each 'card' has the details of a car for sale. The issue we ran into is that not all of them have the odometer reading, which is the critical variable we're going to use in our modelling later. To get around this, we use a some convoluted XPath. We find all the <li> tags that have the odometer reading, then go back up the tree to find the ancestor <div> tags that define the entire card. This ensures that all the cards we've pulled out have odometer readings. 

From there, it's trivial to extract specific properties from the car sale.

```{r eval = FALSE}
kluger_data <-
    kluger_source |> 
    mutate(
        # Get entires that have odometer
        cards = map(source, ~html_elements(.x, xpath = "//li[@data-type = 'Odometer']/ancestor::div[@class = 'card-body']")),
        # Extract specific values of each car sale
        price = map(cards, ~xpt(.x, xpath = ".//a[@data-webm-clickvalue = 'sv-price']")),
        title = map(cards, ~xpt(.x, xpath = ".//a[@data-webm-clickvalue = 'sv-title']")),
        odometer = map(cards, ~xpt(.x, xpath = ".//li[@data-type = 'Odometer']")),
        body = map(cards, ~xpt(.x, xpath = ".//li[@data-type = 'Body Style']")),
        transmission = map(cards, ~xpt(.x, xpath = ".//li[@data-type = 'Transmission']")),
        engine = map(cards, ~xpt(.x, xpath = ".//li[@data-type = 'Engine']"))
    ) |>
    select(-c(source, cards)) |>
    unnest(everything())
```

```{r include=FALSE}
kluger_data <- read_csv('data/carsales_kluger.csv')
```

At this stage, the data is a bit raw: the odometer and price are character strings with dollar signs and commas, and other important pieces of info are in the title:

```{r echo=FALSE, comment=""}
str(kluger_data)
```

After a bit of cleaning, we've got the data we need:

```{r, comment=''}
kluger_data <-
kluger_data |>
    mutate(
        odometer = parse_number(odometer),
        odometer_Mm = odometer / 1000,
        price = parse_number(price),
        year = as.integer( str_extract(title, "^(\\d{4})", group = TRUE) ),
        drivetrain = str_extract(title, "\\w+$"),
        model = str_extract(title, "Toyota Kluger ([-\\w]+)", group = TRUE)
    )

str(kluger_data)
```

# Taking a Quick Look

Let's take a look at some of the key features of the data. First up, how does the market price for a Kluger change as the odometers (in Megametres) rack up. 

```{r echo = FALSE}
kluger_data |>
    ggplot() +
    geom_point(aes(odometer_Mm, price, colour = model), alpha = .5) +
    labs(
        title = "Market for Toyota Klugers",
        subtitle = "Odometer Versus Price",
        x = "Odometer (megametres)",
        y = "Price ($)",
        colour = "Model"
    ) + 
    scale_x_continuous(labels = scales::comma) +
    scale_y_continuous(labels = scales::comma) +
    theme(axis.text.x = element_text(angle = 45, hjust = 1))
```
The thing I notice is that looks suspiciously like there's some sort of negative exponential relationship between the the odometer and price. What if we take a look at the odometer versus the log of the price?

```{r echo = FALSE}
kluger_data |>
    ggplot() +
    geom_point(aes(odometer_Mm, log(price), colour = model)) +
    labs(
        title = "Toyota Kluger Market",
        subtitle = "Odometer Versus Log(Price)",
        x = "Odometer (megametres)",
        y = "Log(Price) ($)"
    ) +
    scale_x_continuous(labels = scales::comma) +
    scale_y_continuous(labels = scales::comma) +
    theme(axis.text.x = element_text(angle = 45, hjust = 1))
```
This is great, we've now got a linear relationship. There's also still a 

```{r echo=FALSE}
kluger_data |>
    ggplot() +
    geom_point(aes(odometer_Mm, log(price), colour = model), alpha = .3) +
    facet_wrap(~model) +
    labs(
        title = "Toyota Kluger Market",
        subtitle = "Odometer versus Log(Price) by Model",
        x = "Odometer (megametres)",
        y = "Log(Price) ($)"
    ) +
    scale_x_continuous(labels = scales::comma) +
    scale_y_continuous(labels = scales::comma) +
    theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

# Modelling
```{r include=FALSE}
model_file_path <- here('content', 'post', '2023-09-28-honest-insurance-company', 'linear.stan')
```

```{r comment=''}
kluger_model <- cmdstan_model(model_file_path)
kluger_model$print()
```
```{r echo=TRUE, comment=''}
kluger_fit <- kluger_model$sample(
    data = compose_data(kluger_data),
    seed = 123,
    chains = 4,
    parallel_chains = 4,
    refresh = 500,
)
```
    
```{r echo = FALSE}
kluger_fit |> 
    gather_draws(a, b) |>
    recover_types() |> 
    ggplot() +
    geom_histogram(aes(.value, fill = as.factor(.chain)), bins = 100) +
    facet_wrap(vars(.variable), scales = 'free') +
    labs(
        title = "Toyota Kluger Market Linear Model",
        subtitle = "Histogram of Posterior Draws of Alpha & Beta Coefficients",
        x = "Coefficient Value",
        y = "Frequency",
        fill = "Chain"
    )
```
```{r echo=FALSE}
kluger_fit |> 
    gather_draws(a,b, sigma) |>
    ggplot() +
    geom_line(aes(.iteration, .value, colour = as_factor(.chain)), alpha = .8) +
    facet_grid(vars(.variable), scales = 'free_y') + 
    labs(
        title = "Toyota Kluger Market Model",
        subtitle = "MCMC Trace Plot",
        x = "Iteration",
        y = "Value",
        colour = "Chain"
    )
```


```{r echo = FALSE}
#fit_mean_a <- kluger_fit$summary()$mean[2]
#fit_mean_b <- kluger_fit$summary()$mean[3]

kluger_fit_animation <-
    kluger_fit |>
    spread_draws(a, b) |>
    recover_types() |> 
    ggplot() +
    geom_point(data = kluger_data, aes(odometer_Mm, log(price))) +
    geom_abline(aes(intercept = a, slope = b, group = .draw), colour = 'lightblue') +
    transition_reveal(.draw) +
    guides(colour = guide_legend(override.aes = list(alpha = 1))) +
    labs(
        title = "Toyota Kluger Market Model",
        subtitle = "Odometer vs Log(Price) with MCMC Coefficients (Draw {frame_along})",
        x = "Odometer (Megametres)",
        y = "Log(Price) ($)"
    )
 
animate(kluger_fit_animation, renderer = gifski_renderer())
```
```{r echo=FALSE, commentl=""}
kluger_summary <-
    kluger_fit |> 
    spread_draws(a,b,sigma) |> 
    summarise_draws(mean, median, sd) 

print(kluger_summary)

line_intercept <- kluger_summary[[2]][1]
line_slope <- kluger_summary[[2]][2]
```

```{r echo=FALSE}
kluger_fit |>
    spread_draws(a,b) |>
    ggplot() +
    geom_point(data = kluger_data, aes(odometer_Mm, price), alpha = .4) +
    geom_function(fun = ~exp(line_intercept + line_slope * .x), linewidth = 1, colour = 'lightblue') +
    labs(
        title = "Toyota Kluger Market Model",
        subtitle = "Odometer vs Price",
        x = "Odometer (Megametres)",
        y = "Log(Price) ($)",
    )
```

```{r echo=FALSE}
kluger_fit |>
    recover_types() |>
    spread_draws(y_s[i]) |>
    sample_frac(size = .1) |>
    select(-c(.chain, .iteration, .draw)) |>
    nest(y_s = y_s) |>
    bind_cols(kluger_data) |>
    unnest(y_s) |>
    ggplot() +
    geom_point(aes(odometer_Mm, y_s), colour = 'lightblue', alpha = .05) +
    geom_point(data = kluger_data, aes(odometer_Mm, log(price)), alpha = .5) +
    labs(
        title = "Toyota Kluger Market Model",
        subtitle = "Odometer vs Log(Price) with Postierior Predictions", 
        x = "Odometer (Megametres)",
        y = "Log(Price) ($)"
    )
```


```{r, comment=''}
kluger_fit$summary()
```

```{sh eval=FALSE, include=FALSE}
docker container stop rsel
docker container rm rsel
```

