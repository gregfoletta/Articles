---
title: Honest Insurance Company
author: Greg Foletta
date: '2023-09-28'
slug: []
categories: [R Bayesian]
tags: []
---

```{r include=FALSE}
library(tidyverse)
library(tidybayes)
library(RSelenium)
library(rvest)
library(glue)
library(cmdstanr)
library(here)
library(tidybayes)
library(bayesplot)
library(gganimate)
library(scales)
library(ggdag)
library(gt)
```

Last month my car - a Toyota Kluger - was run into while parked in front of my house. Luckily no one was injured and while annoying, the person had insurance (coincidently with the same company as my). The insurance company came back and determined that the car had been written off and I would be paid out the market value of the car. But what is the market value? How could I keep the insurance company honest and make sure I wasn't getting stiffed?

In this post I'll go through the process I used to keep the insurance company honest. There's data acquisition and visiualisation of the current market, then modelling of the market price. 

# Data Aquisition

The first step was to acquire some data on the current market for Toyota Klugers. I used [carsales.com.au](https://www.carsales.com.au/cars/used/toyota/kluger/) as my source. The Carsales site requires Javascript to render, so simply requesting the pages wasn't going to work. Instead we need to render the page in a browser. To do this I used a docker instance of the webdriver [Selenium](https://www.selenium.dev/), interfacing into this with the R package [RSelenium](https://github.com/ropensci/RSelenium). This allows us to browse to the site from a 'remotely controller' browser, Javascript and all, and retrieve the information we need.

First up, we connect to the docker instance, setting the page load strategy to eager so that it will return when the initial HTML is loaded and not wait for stylesheets, images, etc.

```{sh eval=FALSE, include=FALSE}
# Stop running containers
if [ $(docker container ls -q --filter name=rsel --all) ]
then
        docker container stop rsel
        docker container rm rsel
fi
```

```{sh eval=FALSE, include=FALSE }
docker run -d -p 4444:4444 --name rsel selenium/standalone-firefox:latest
```

```{r eval = FALSE, echo=TRUE, results = 'hide'}
rs <- remoteDriver(remoteServerAddr = '172.17.0.2', port = 4444L)
rs$extraCapabilities$pageLoadStrategy <- "eager"
rs$open()
```

Each page of Klugers for sale is determined by an offset of 12. We generate the offsets (12, 24, 36 etc) and the URIs based on these offsets. We then navigate to each page, reading the source, and parsing into a structuered XML document.

```{r eval = FALSE}
kluger_source <-
    tibble(
        # Generate offsets
        offset = 12 * c(0:100),
        # Create URIs based on offsets
        uri = glue("https://www.carsales.com.au/cars/used/toyota/kluger/?offset={offset}")
    ) |> 
    mutate(
        # Naviate to each URI, read and parse the source
        source = map(uri, ~{ 
            rs$navigate(uri)
            rs$getPageSource() |> pluck(1) |> read_html()
        } )
    )
```

With the raw source in our hands, we can move on to extracting the pieces of data we need from each of them.

# Data Extractiion

First up, we define a small helper function which finds an element based on its XPath, and pulls out the text of that element.

```{r}
# XPath helper function, xpt short for xpath_text
xpt <- function(html, xpath) {
    html_elements(html, xpath = xpath) |> 
    html_text()
}
```

Each 'card' has the details of a car for sale. The issue we ran into is that not all of them have the odometer reading, which is the critical variable we're going to use in our modelling later. To get around this, we use a some convoluted XPath. We find all the <li> tags that have the odometer reading, then go back up the tree to find the ancestor <div> tags that define the entire card. This ensures that all the cards we've pulled out have odometer readings. 

From there, it's trivial to extract specific properties from the car sale.

```{r eval = FALSE}
kluger_data <-
    kluger_source |> 
    mutate(
        # Get entires that have odometer
        cards = map(source, ~html_elements(.x, xpath = "//li[@data-type = 'Odometer']/ancestor::div[@class = 'card-body']")),
        # Extract specific values of each car sale
        price = map(cards, ~xpt(.x, xpath = ".//a[@data-webm-clickvalue = 'sv-price']")),
        title = map(cards, ~xpt(.x, xpath = ".//a[@data-webm-clickvalue = 'sv-title']")),
        odometer = map(cards, ~xpt(.x, xpath = ".//li[@data-type = 'Odometer']")),
        body = map(cards, ~xpt(.x, xpath = ".//li[@data-type = 'Body Style']")),
        transmission = map(cards, ~xpt(.x, xpath = ".//li[@data-type = 'Transmission']")),
        engine = map(cards, ~xpt(.x, xpath = ".//li[@data-type = 'Engine']"))
    ) |>
    select(-c(source, cards, offset)) |>
    unnest(everything())
```

```{r include=FALSE}
kluger_data <- read_csv('data/carsales_kluger.csv') |> select(-offset)
```

At this stage, the data is a bit raw: the odometer and price are character strings with dollar signs and commas, and other important pieces of info are in the title:

```{r echo=FALSE, comment=""}
slice_sample(kluger_data, n = 200) |>
    gt() |> 
    opt_interactive()
```

There's a small amount of housekeeping to be done. The price and odometer are in a textual format, so these are converted to integers. we also create a new *megametre* variable (i.e. thousands of kilometers). The year, model, and drivetrain are pulled out of the title of the advert using regex.

```{r, comment=''}
kluger_data <-
kluger_data |>
    mutate(
        odometer = parse_number(odometer),
        odometer_Mm = odometer / 1000,
        price = parse_number(price),
        year = as.integer( str_extract(title, "^(\\d{4})", group = TRUE) ),
        drivetrain = str_extract(title, "\\w+$"),
        model = str_extract(title, "Toyota Kluger ([-\\w]+)", group = TRUE)
    )
```

```{r echo=FALSE}
slice_sample(kluger_data, n = 200) |>
    gt() |> 
    opt_interactive()
```

# Taking a Quick Look

Let's visualise key features of the data. First up we'll, how does the market price for a Kluger change as the odometers (in megametres):

```{r echo = FALSE}
kluger_data |>
    ggplot() +
    geom_point(aes(odometer_Mm, price, colour = model), alpha = .5) +
    labs(
        title = "Market for Toyota Klugers",
        subtitle = "Odometer Versus Price",
        x = "Odometer (megametres)",
        y = "Price ($)",
        colour = "Model"
    ) + 
    scale_x_continuous(labels = scales::comma) +
    scale_y_continuous(labels = scales::comma) +
    theme(axis.text.x = element_text(angle = 45, hjust = 1))
```
The thing I notice is that looks suspiciously like there's some sort of negative exponential relationship between the the odometer and price. What if we take a look at the odometer versus the log of the price?

```{r echo = FALSE}
kluger_data |>
    ggplot() +
    geom_point(aes(odometer_Mm, log(price), colour = model)) +
    labs(
        title = "Toyota Kluger Market",
        subtitle = "Odometer Versus Log(Price)",
        x = "Odometer (megametres)",
        y = "Log(Price) ($)"
    ) +
    scale_x_continuous(labels = scales::comma) +
    scale_y_continuous(labels = scales::comma) +
    theme(axis.text.x = element_text(angle = 45, hjust = 1))
```
This is great; with the log transform we've now got a linear relationship between the number odometer of the car and the price. We're going to end up trying to fit a line to this data, and the log transform provides a nice interpretation for the slope of this line. You might recall that in general when you fit a line to x and y, the slope (\\(beta\\)) of that line is "the change in the y variable given a change of one unit of the x variable". When you fit a line to to x and log(y) (called log-linear), for small \\(\beta\\), \\(e^\beta\\) is the percentage change in y for a one unit change of x. 

Here's the same view, but we split it out by model:

```{r echo=FALSE}
kluger_data |>
    ggplot() +
    geom_point(aes(odometer_Mm, log(price), colour = model), alpha = .3) +
    facet_wrap(~model) +
    labs(
        title = "Toyota Kluger Market",
        subtitle = "Odometer versus Log(Price) by Model",
        x = "Odometer (megametres)",
        y = "Log(Price) ($)"
    ) +
    scale_x_continuous(labels = scales::comma) +
    scale_y_continuous(labels = scales::comma) +
    theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

# Modelling

```{r echo=FALSE}
dag_coords <- tribble(
    ~name,    ~x,    ~y, 
    "price",   0,     0,
    "odom.",   1,    -1,
    "year",    1,     0,
    "model",   1,     1,
    "drvtrn",  1,     2,
    "cond.",   0,     2,
)
    
generative_dag<- 
    dagify(
        price ~ odom. + year + model + cond. + drvtrn,
        drvtrn ~ model,
        odom. ~ year,
        coords = dag_coords
    ) |> 
    tidy_dagitty() |>
    mutate(
        type = case_when(
            name == 'price' ~ "Outcome",
            name == 'cond.' ~ "Unobserved",
            .default = "Predictor"
        )
    )

generative_dag |> 
    ggdag() +
    geom_dag_point(aes(colour = type)) +
    geom_dag_text() +
    theme_dag_blank() +
    labs(
        title = "Toyota Kluger Pricing Generative Model",
        subtitle = "Directed Acyclic Graph",
        colour = "Variable Type"
    )
```
With our data in hand, what we want to do is create a model that helps us predict the sell price of a Toyota Kluger. In the interests of starting with a very simple model, we're only going use the odometer reading as a single predictor variable. This means there's likely a log of 

```{r include=FALSE}
model_file_path <- here('content', 'post', '2023-09-28-honest-insurance-company', 'linear.stan')
```

```{r comment=''}
kluger_model <- cmdstan_model(model_file_path)
kluger_model$print()
```
```{r echo=TRUE, comment=''}
kluger_fit <- kluger_model$sample(
    data = compose_data(kluger_data),
    seed = 123,
    chains = 4,
    parallel_chains = 4,
    refresh = 500,
)
```

# Assessing the Model

```{r echo = FALSE}
kluger_fit |> 
    gather_draws(a, b) |>
    recover_types() |> 
    ggplot() +
    geom_histogram(aes(.value, fill = as.factor(.chain)), bins = 100) +
    facet_wrap(vars(.variable), scales = 'free') +
    labs(
        title = "Toyota Kluger Market Linear Model",
        subtitle = "Histogram of Posterior Draws of Alpha & Beta Coefficients",
        x = "Coefficient Value",
        y = "Frequency",
        fill = "Chain"
    )
```
```{r echo=FALSE}
kluger_fit |> 
    gather_draws(a,b, sigma) |>
    ggplot() +
    geom_line(aes(.iteration, .value, colour = as_factor(.chain)), alpha = .8) +
    facet_grid(vars(.variable), scales = 'free_y') + 
    labs(
        title = "Toyota Kluger Market Model",
        subtitle = "MCMC Trace Plot",
        x = "Iteration",
        y = "Value",
        colour = "Chain"
    )
```


```{r echo = FALSE}
#fit_mean_a <- kluger_fit$summary()$mean[2]
#fit_mean_b <- kluger_fit$summary()$mean[3]

kluger_fit_animation <-
    kluger_fit |>
    spread_draws(a, b) |>
    recover_types() |> 
    ggplot() +
    geom_point(data = kluger_data, aes(odometer_Mm, log(price))) +
    geom_abline(aes(intercept = a, slope = b, group = .draw), colour = 'lightblue') +
    transition_reveal(.draw) +
    guides(colour = guide_legend(override.aes = list(alpha = 1))) +
    labs(
        title = "Toyota Kluger Market Model",
        subtitle = "Odometer vs Log(Price) with MCMC Coefficients (Draw {frame_along})",
        x = "Odometer (Megametres)",
        y = "Log(Price) ($)"
    ) +
    scale_x_continuous(labels = scales::comma) +
    scale_y_continuous(labels = scales::comma) +
    theme(axis.text.x = element_text(angle = 45, hjust = 1))
 
animate(kluger_fit_animation, renderer = gifski_renderer())
```


```{r echo=FALSE}
kluger_fit |>
    recover_types() |>
    spread_draws(y_s[i]) |>
    sample_frac(size = .1) |>
    select(-c(.chain, .iteration, .draw)) |>
    nest(y_s = y_s) |>
    bind_cols(kluger_data) |>
    unnest(y_s) |>
    ggplot() +
    geom_point(aes(odometer_Mm, y_s), colour = 'lightblue', alpha = .05) +
    geom_point(data = kluger_data, aes(odometer_Mm, log(price)), alpha = .5) +
    labs(
        title = "Toyota Kluger Market Model",
        subtitle = "Odometer vs Log(Price) with Postierior Predictions", 
        x = "Odometer (Megametres)",
        y = "Log(Price) ($)"
    )
```

# Model Outcomes

```{r echo=FALSE, commentl=""}
kluger_summary <-
    kluger_fit |> 
    spread_draws(a,b,sigma) |> 
    summarise_draws(mean, median, sd) 

kluger_summary |> gt()

line_intercept <- kluger_summary[[2]][1]
line_slope <- kluger_summary[[2]][2]

```

```{r}
kluger_quantile <-
    kluger_fit |>
    spread_draws(price_pred) |>
    reframe(
        interval = c(.11, .89),
        value = quantile(price_pred, interval)
    ) |>
    spread(interval, value)

kluger_fit |>
    recover_types() |>
    spread_draws(price_pred) |>
    ggplot() +
    geom_histogram(aes(price_pred), bins = 200) +
    geom_vline(xintercept = kluger_quantile[['0.11']], color = 'blue', linewidth = 1, linetype = 'dotted') +
    geom_vline(xintercept = kluger_quantile[['0.89']], color = 'blue', linewidth = 1, linetype = 'dotted') +
    scale_x_continuous(labels = scales::dollar) +
    scale_y_continuous(labels = scales::comma) +
    theme(axis.text.x = element_text(angle = 45, hjust = 1)) + 
    labs(
        x = "Count",
        y = "Predicted Price ($)",
        title = "Toyota Kluger Price Prediction",
        subtitle = "Distribution of Price Prediction at 60,000km"
    )
```



```{r echo=FALSE}
kluger_fit |>
    spread_draws(a,b) |>
    ggplot() +
    geom_point(data = kluger_data, aes(odometer_Mm, price), alpha = .4) +
    geom_function(fun = ~exp(line_intercept + line_slope * .x), linewidth = 1, colour = 'lightblue') +
    labs(
        title = "Toyota Kluger Market Model",
        subtitle = "Odometer vs Price",
        x = "Odometer (Megametres)",
        y = "Price ($)",
    )
```



```{r, comment=''}
kluger_fit$summary()
```

```{sh eval=FALSE, include=FALSE}
docker container stop rsel
docker container rm rsel
```

