---
title: Git Under the Hood
author: 'Greg Foletta'
date: '2022-03-19'
slug: git-under-the-hood
categories: [git]
---

```{zsh include=FALSE}
touch file_x
rm -rf .git file_* subdir
```

```{r include=FALSE}
library(tidyverse)
library(tidygraph)
library(ggraph)
library(git2r)
library(stringr)
library(glue)

knitr::opts_chunk$set(
    comment = ''
)

```


```{r include=FALSE}
repo_nodes <- function(repo = '.') {
    # First get all of the objects in the repo
    one_commit_nodes <- 
        odb_objects(repo = repo) 
    
    # We then want to add a 'content' column with:
    #   - Content of the blobs
    #   - Nothing for the trees
    #   - Commit message for the commits
    
    # First adding the blob content
    one_commit_nodes <-
        one_commit_nodes %>% 
        filter(type == 'blob') %>%
        select(sha) %>% 
        mutate(content = map(sha, ~content(lookup(repo, sha = .x)))) %>% 
        right_join(one_commit_nodes, by = 'sha')
   
    one_commit_nodes <-
        one_commit_nodes %>%
        filter(type == 'commit') %>%
        select(sha) %>%
        mutate(message = map(sha, ~ {
            lookup(repo, sha = .x) %>% as.data.frame() %>% magrittr::extract2('message')
        })) %>% 
        right_join(one_commit_nodes, by = 'sha')
    
    one_commit_nodes
}

repo_edges <- function(repo = '.') {
    
# Pull out tree objects, run ls_tree to list what they
# point to which becomes out edges
tree_to_blob_edges <-
    odb_objects(repo = repo) %>% 
    filter(type == 'tree') %>% 
    mutate(blobs = map(sha, ~ls_tree(.x, recursive = FALSE))) %>%
    unnest(blobs, names_repair = 'universal') %>% 
    select(
        from = sha...1,
        to = sha...6,
    )


# Pull out the commits and add an edge from the commit to the root tree
commit_to_tree <-
    odb_objects(repo = repo) %>%
    filter(type == 'commit') %>%
    mutate(tree = map_chr(sha, ~ {
        lookup(repo, .x) %>% tree() %>% .$sha
    })) %>%
    mutate(parent_commit = map(sha, ~ {
        lookup(repo, .x) %>% parents() %>% as.data.frame()  %>% magrittr::extract2('sha')
    })) %>%
    unnest(parent_commit, keep_empty = TRUE) %>% 
    select(
        from = sha,
        to = tree
    )

commit_to_parent_commit <-
    odb_objects(repo = repo) %>%
    filter(type == 'commit') %>%
    mutate(parent_commit = map(sha, ~ {
        lookup(repo, .x) %>% parents() %>% as.data.frame()  %>% magrittr::extract2('sha')
    })) %>%
    unnest(parent_commit) %>% 
    select(
        from = sha,
        to = parent_commit 
    )

    bind_rows(
        tree_to_blob_edges,
        commit_to_tree,
        commit_to_parent_commit
    )
}

git_graph <- function(graph) {
    graph %>% 
    ggraph(layout = 'sugiyama') +
    geom_node_point(aes(colour = type), size = 10) +
    geom_edge_link(arrow = arrow(type = 'closed', length = unit(4, units = 'mm'))) +
    geom_node_label(aes(filter = type == 'commit', label = glue("{ str_sub(sha, end = 4)}\n'{ str_trim(message) }'")), repel = TRUE) +
    geom_node_label(aes(filter = type == 'tree', label = glue("{ str_sub(sha, end = 4)}")), repel = TRUE) +
    geom_node_label(aes(filter = type == 'blob', label = glue("{ str_sub(sha, end = 4)}\n'{ content }'")), repel = TRUE)
}
```


# Initialisation

We'll start by initialising an empty git repository. This creates a *.git* directory in the root directory of the repository. It's a root in that all subdirectories and files below this point will be considered part of the the repository.

There's a bunch of stuff that's created, but we'll prune it back to the absolute bare minimum of what git considers a git repository.

```{zsh}
git init -q
rm -rf .git/{hooks,info,config,branches,description}
rm -rf .git/objects/{info,pack}
rm -rf .git/refs/{heads,tags}

tree .git
```


# Blobs

The first fundamental git object we'll look at is the *blob*. Let's create a file and use the `git add` command to add it to the staging area and see what this has done in our .git directory.

```{zsh}
echo "Hello" > file_x
git add file_x

tree .git
```

We see that a new object has been created in what looks like some sort of hash value. The file is compressed data.

```{zsh}
file .git/objects/e9/65047ad7c57865823c7d992b1d046ea66edf78
```

If we decompress and look inside, we can see the file is in a "type, length, value" or TLV format, with the type being a blob, the length of the value being 6 bytes, and the value being "Hello".


```{zsh}
pigz -cd .git/objects/e9/65047ad7c57865823c7d992b1d046ea66edf78 | hexdump -C
```


All data in git is stored in this manner. So what we can say is that git is an object store for data, where the objects are addressed by a hash. 

A key point to note at this stage is that there's no information about the file contained in these blobs: no path or file name, no permissions. It's only the contents of the file. 

How is this hash calculated? It's simply the SHA2 hash of the TLV. 

```{zsh}
echo "blob 6\0Hello" | shasum
```

Let's explore this further. We'll create a subdirectory and add two more files, one of which will have the same contents as our first file.

```{zsh}
mkdir subdir

echo "Hello" > subdir/file_z
echo "Hello Again" > subdir/file_y

git add subdir

tree .git
```

Two things that stand out here. First is that while we have a total of three files, there's only two objects. This is because blobls are only concerned with the contents of the files, and we have only two unique pieces of content.

The second is that, like the filenames, theres no reference to the subdirectory here either. We'll see in the next section where this information is stored.

Over the course of the article we'll build up a graph of the objects in the git repository. Here's out starting point: two blobs, the first four characters of their hash, and their contents.

```{r echo=FALSE, message=FALSE, warning=FALSE}
tbl_graph(
    nodes = repo_nodes()
) %>%
    git_graph() +
    labs(
        title = 'Git Object Structure',
        subtitle = 'Blob Objects'
    )

```


# Tree

So where is the file system information stored? This is the role of the tree object. If we use the analogy of a disk filesystem and the blob is the raw data on the disk, then the tree object is similar to the inode. It holds the metadata of the file, as well as a pointer to the blob object.

Let's perform our first commit and see what's changed in the repository.

```{zsh}
git commit -m "First Commit"

tree .git
```

Ok, there's a lot there, but let's focus in again on the objects where we have an additional three. I've done the hard work of determining which is which, so let's take a look at the first of the tree objects.

```{zsh}
pigz -cd .git/objects/2b/04fd32b556e89dfa44b332f0cc59541879189a | hexdump -C
```

This is a little harder to interpret as some of the information is in a binary representation. Again I've done the hard to work to determine the structure, so we can unpack it into a friendlier, plain-text representation:

```{zsh}
pigz -cd .git/objects/2b/04fd32b556e89dfa44b332f0cc59541879189a |\
perl -nE 'print join "\n", unpack("Z*(Z*H40)*")'
```
Again we have the type of object, then the of the tree object. Then we have an entry for each of the filesystem objects in the root of our git repository. The first is the *file_x* file, with its permnissions, it's filename, and a pointer to the blob object of its contents.

**Add note on limited permissions**.

The second is the subdir directory, but instead of pointing to a blob object, this points to another tree object. Taking a look inside that:

```{zsh}
pigz -cd .git/objects/44/9a4c7ba21764840c8abc1eb9698596fdf33f3d |\
perl -nE 'print join "\n", unpack("Z*(Z*H40)*")'
```
This object point to the two files within that subdirectory. Keen eyes may notice that both *file_x* in the root and *file_z* point to the same hash, as those files have the same contents. 

We can visualise this as a graph:
    
```{r echo=FALSE, message=FALSE, warning=FALSE}
# Create the graph, filtering out the commit
tbl_graph(
    nodes = repo_nodes(),
    edges = repo_edges()
) %>%
    filter(type != 'commit') %>% 
    git_graph() +
    labs(
        title = 'Git Object Structure',
        subtitle = 'Tree and Blob Objects'
    )
``` 
The hash value of the tree objects is directly dependent on the name of the file/directory, and its permissions. But it's indirectly dependent on the contents of the files: if that changes, the hash of the blob changes, and so the hash of the tree changes.

# Commit

```{zsh}
COMMIT_DIR=$(git show HEAD --pretty=format:"%H" --no-patch | cut -c 1-2)
COMMIT_OBJ=$(git show HEAD --pretty=format:"%H" --no-patch | cut -c 3-)

pigz -cd .git/objects/$COMMIT_DIR/$COMMIT_OBJ |
perl -0777 -nE 'print join "\n", unpack("Z*A*")'
```

```{r echo=FALSE, message=FALSE, warning=FALSE}
# Create the graph, this time without filtering the commit
tbl_graph(
    nodes = repo_nodes(),
    edges = repo_edges()
) %>%
    git_graph() +
    labs(
        title = 'Git Object Structure',
        subtitle = 'Tree and Blob Objects'
    )
```

```{zsh}
echo "Hello Root" > subdir/file_z
git add subdir/file_z
git commit -m "Second Commit"
```

```{zsh}
COMMIT_DIR=$(git show HEAD --pretty=format:"%H" --no-patch | cut -c 1-2)
COMMIT_OBJ=$(git show HEAD --pretty=format:"%H" --no-patch | cut -c 3-)

pigz -cd .git/objects/$COMMIT_DIR/$COMMIT_OBJ |
perl -0777 -nE 'print join "\n", unpack("Z*A*")'
```
```{r echo=FALSE, message=FALSE, warning=FALSE}
# Create the graph, this time without filtering the commit
tbl_graph(
    nodes = repo_nodes(),
    edges = repo_edges()
) %>%
    git_graph() +
    labs(
        title = 'Git Object Structure',
        subtitle = 'Multiple Commit Hierarchy'
    )
```


# Branches

```{zsh}
cat .git/HEAD
cat .git/refs/heads/master
```

# Index
```{zsh}
perl -MData::Dumper -0777 -nE '
my @index = unpack("A4 H8 N/(N4 N2 B16 B16 N N N H40 B8 W/A B16 x![4])");
say join(" ", @index[ ($_ * 15) + 2 ..  ($_ * 15) + 17])  foreach (0 .. (scalar (@index - 2) / 15) - 1)
' .git/index
```



```{zsh include=FALSE}
rm -rf .git file_* subdir
```

