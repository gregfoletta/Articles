---
title: Cracking Open SCEP
author: 'Greg Foletta'
date: '2024-07-01'
categories: [Shell PKI]
output:
    html_document:
        code_folding: hide
---

```{r include=FALSE}
knitr::opts_chunk$set(comment = '')
```

Most of the posts on this site tend to be long form, a result of me finding it hard to leave stones unturned. This leads to big gaps between posts, in fact the the radio silence over the past nine months is because I've had two in draft form, not quite neing able to get them across the line.

As an antidote to this I've put together something a little more bite-size. In this post we're going to crack open a *Simple Certificate Enrollment Protocol (SCEP)* request. We'll do this on the command line, using the openssl tool peer underneath the hood.

# The Request

Here's a screenshot of a packet capture taken during a SCEP request for a new certificate.

![SCEP Capture](scep_capture.png)
The SCEP request is actually two requests: the first returns X509 CA certificate, and the second is the certificate request. Zooming in on the second one, the bulk of the request is passed in the *message* query parameter. What I've done is extracted the value of this parameter into a file named *scep_message*.

```{sh}
# Size in bytes
wc -c scep_message
# First 64 bytes
cut -c1-64 scep_message 
```

As you'll soon see, SCEP has an onion like quality (often including the tears), with layer after layer of different encodings and structures. The *message* parameter is URI encoded, then base64 encoded, so we decode these store what I'll call the 'raw' SCEP in a file called *scep_raw*.

```{sh}
# Remove the URI and base64 encoding
< scep_message perl -MURI::Escape -e 'print uri_unescape(<STDIN>)' | base64 -d > scep_raw
```

# Signing

Now we can get into the meat and bones. The first wrapper is [Cryptographic Message Syntax (CMS)](https://en.wikipedia.org/wiki/Cryptographic_Message_Syntax) encapsulated data. Originally part of the PKCS standards defined by RSA security, it is now an IETF standard under [RFC 5652 ](https://datatracker.ietf.org/doc/html/rfc5652). CMS provides a way to 'digitally sign, digest, authenticate, or encrypt arbitrary message content'. 

Using the openssl *cms* command with the *-print* argument, we can look at the structure of this first CMS wrapper. I've redacted some of the less-relevant content and added some comments, but some of the key sections are:

* *eContent*: the encapsulated content.
* *certificates*: a set of certificates that are sent along with the content.
* *signerInfos*: information pertaining to the signing of the content.

```{sh class.output='language-sh', class.source = 'fold-hide'}
# Print the CMS structure
openssl cms -in scep_raw -cmsout -inform DER -print
```
```{sh}
# Extract the self signed certificate
openssl cms -verify -in scep_raw -inform DER -signer self_signed.cer -noverify -out /dev/null
```


# Encryption

The keen eyed will have noticed that the `eContentType` was `pkcs7-data`. I.e. inside this CMS encapsulation is another CMS encapsulation, except this one is responsible for encrypting the certificate request.

Using the *-verify* command we can verify the signature and extract the content. The seemingly contradictory *-noverify* disables verification of the signing certificate of the message, while still checking the signature. We can't verify the certificate because at this point it's a self-signed certificate.

As before, we use take a look at the much simpler structure:

```{sh class.source='language-sh'}
openssl cms -verify -in scep_raw -inform DER -signer self_signed.cer -noverify |
  openssl cms -inform DER -cmsout -print
```
The content-encryption key is randomly generated and used to encrypt the data, then the key itself is encrypted using the signing CA that we received in that first step. I have a copy of the private key of the signing CA ("Blog Post SubCA"), so we can decrypt the content and look at the request.

# The CSR 

Using the *-decrypt* option and the certificate & private key of the signing CA, we can decrypt the CMS content, leaving us with the pure certificate request.

```{sh}
# Extract verified data
< scep_raw openssl cms -verify -noverify -in - -inform DER -out - |
# Extract encrypted data
  openssl cms -inform DER -decrypt -recip Blog_Post_SubCA.cer -inkey Blog_Post_SubCA.key |
# Parse ceertificate request
  openssl req -inform DER -noout -text
```


# Response

The response from the SCEP server containing the certificate is similar: there's the verification CMS, signed using the public key in the certificate request. Within that is the encrypted CMS, signed by the issuing CA. The difference is at the core is a 'degenerate

```{sh}
# Extract verified response
openssl cms -verify -in scep_response -inform der |
# Decrypt response
openssl cms -decrypt -inform der -recip self_signed.cer -inkey blog.key |
# View 'degenerate' signed data certificates 
openssl pkcs7 -inform der -noout -print_certs -text
```

