---
title: 'What the #!'
author: Greg Foletta
date: '2021-04-19'
slug: []
categories: []
tags: []
images: []
---

```{r, include = FALSE}
knitr::opts_chunk$set(comment = '')
```


Whenever you work with computers, you take an incredible amount of things for granted: your press of the keyboard will bubble up through the kernel to your terminal, the HTTP request will remain intact after travelling halfway across the globe; or the stream of a cat video will be decoded and rendered on your screen. Taking these things for granted isn't a negative, in fact quite the opposite. All of the abstractions and indirections that hide the internal details allow us to focus on other important aspects like aesthetics, speed or accuracy, rather than wondering how exactly how re-implement TCP.

But at the same time in can be a very unsatisfying feeling to not know how something is working, and you need to peek behind the curtains. For me that happened recently when writing a script and adding the obligatory "shebang" or "hashbang" (#!) to the first line. Of course I know that this specifies the interpreter that will run the rest of the file, but how does that work? Is it a user space or kernel space component that does this?  

So in this article we're going to answer the question:

> How is an interpreter caled when specified using a shebang in the first line of a script? 

```{sh}
uname -sor
```


# Done In Userspace

Let's dive straight in - here's our simple Perl script that we're running.

```{sh}
cat data/foo.pl

chmod u+x data/foo.pl
```

The first tool we go for is `strace`, which attaches itself to a process and intercepts system calls. In the below code snippet, we run strace with two arguments: the '-f' means that any child processes spawned by the original traced process are traced as well. The -e argument filters out specific system calls that we're interested in. I've done this for brevity within the article, but you'd likely want to look through the whole trace to get a firm idea about what the process is doing.

We spin up a bash process, then execute our script within that process.


```{sh}
strace -f -e trace=vfork,fork,clone,execve bash -c './data/foo.pl argument_1 argument_2'
```

The strace utility shows us two processes executions: the bash shell executing (which will have followed the `clone()` call from the original shell and not captured), then the path of our script being passed directly to the `execve()` system call. This is a system call that executes processes. It's prototype is:

```c
int execve(
    const char *filename,
    char *const argv[],
    char *const envp[]
);
```

with `*filename` containing the path to the program to run, `*argv[]` containing the command line arguements, and `*envp[]` containing the environment variables.

What does this tell us? It tells us that the scripts are passed directly this system call, and there's no userspace aspect to the parsing of the hash-bang line.

# A Quick Look in GLIBC

The bash process doesn't call the system call directly; the `execve()` function is part of the standard C library (on my machine it's glibc or GNU LibC), to which bash is dynamically linked. While it's unlikely that anything of significance is ocurring in the library, we'd better take a look.

We can use the `ldd` utility to print out the shared libraries required a program, and the paths to these shared libraries.

```{bash}
ldd $(which bash)
```

We now use `objdump` to disassemble the shared library, and we extract out the section that's related to `execve()`.

```{bash}
objdump -d /lib/x86_64-linux-gnu/libc.so.6 | sed -n '/^[[:xdigit:]]\+ <execve/,/^$/p' 
```

As expected, the standard library doesn't do much. It places 0x3b (decimal 59) into the `eax` register, which is the [execve system call number](https://elixir.bootlin.com/linux/latest/source/arch/x86/entry/syscalls/syscall_64.tbl#L70) and calls the [fast system call x86 instruction](https://www.felixcloutier.com/x86/syscall). 

I could write another whole article on the process of jumping from user space into the kernel through a system call. You'll find a brief description of the steps in the appendix at the bottom of this article.



# Delving into the kernel

We'll start our journey in the kernel at [SYSCALL_DEFINE3(execve)](https://elixir.bootlin.com/linux/v4.15/source/fs/exec.c#L1923), which calls [do_execve()](https://elixir.bootlin.com/linux/v4.15/source/fs/exec.c#L1841), which calls [do_execveat_common()](https://elixir.bootlin.com/linux/v4.15/source/fs/exec.c#L1694). This function initialises the [linux_binprm](https://elixir.bootlin.com/linux/v4.15/source/include/linux/binfmts.h#L17) structure. The members relevant to the calling of a script are:

- `char buf[BINPRM_BUF_SIZE]`, which will hold the first 128 bytes of the file.
- `unsigned int recursion_depth`, which tracks how far deep our binary handler search goes.
- `int argc, envc`: our command line argument and environment counts
- `const char * filename` - the name of the binary that's seen by the 'ps' utility. 
- `const char * interp` - name of the binary that was really executed.

Both the `filename` and `interp` members are set to the path of the file to be executed, and the `argc` and `envc` members are set to the respective counts. The `buf` member is then zeroed out and the first `BINPRM_BUF_SIZE` bytes (which is 128 in this version of the kernel) of the file is copied into it.

At this stage, the `argv` and `envp` pointers still point to the stack of calling process. Memory is allocated for the new process's stack, and these strings are copied into it.

The [exec_binprm](https://elixir.bootlin.com/linux/v4.15/source/fs/exec.c#L1669) function is then called. The main responsibility of this function is to call [search_binary_handler](https://elixir.bootlin.com/linux/v4.15/source/fs/exec.c#L1616). This is where things get interesting.

# Binary Handler Search

The binary handler is responsible for iterating through the list of supported binary formats, and dispatching the `load_binary()` function of each one. I've included the code below, minus some tangential items like locking and security checks:

```c
int search_binary_handler(struct linux_binprm *bprm)
{
	struct linux_binfmt *fmt;
	int retval;
	...
	/* This allows 4 levels of binfmt rewrites before failing hard. */
	if (bprm->recursion_depth > 5)
		return -ELOOP;
	...

	list_for_each_entry(fmt, &formats, lh) {
	    ...
		bprm->recursion_depth++;
		retval = fmt->load_binary(bprm);
		bprm->recursion_depth--;
		...
	}
	...
	return retval;
}
```

The `formats` is a linked list of [linux_binfmt](https://elixir.bootlin.com/linux/v4.15/source/include/linux/binfmts.h#L92) structures. Some of these are defined in the kernel, but they can also be loaded via loadable kernel modules. These are registered using the [register_binfmt()](https://elixir.bootlin.com/linux/v4.15/C/ident/register_binfmt) function. The built-in These include the common ELF format, the older a.out format, but the one we are most interested in is the 'script' format.

Here's the structure and the code code that registers the script format:

```c
static struct linux_binfmt script_format = {
	.module		= THIS_MODULE,
	.load_binary	= load_script,
};

static int __init init_script_binfmt(void)
{
	register_binfmt(&script_format);
	return 0;
}
```

We can see that the `load_binary` function pointer that the `search_binary_handler()` function will dispath is the `load_script()` function. Let's now turn our attention to this.


# Script Binary Format

The `load_script()` function must first determine whether it is the appropriate handler for the file that's being executed. The `binprm` structure has the first 128 bytes of the file to be executed in the `buf` member. It looks at the first two bytes and checks whether they are the hash-bang. If not then it returns `-ENOEXEC`.

```c
static int load_script(struct linux_binprm *bprm)
{
	const char *i_arg, *i_name;
	char *cp;
	struct file *file;
	int retval;

	if ((bprm->buf[0] != '#') || (bprm->buf[1] != '!'))
		return -ENOEXEC;
```

The rest of the function can be broken down into three parts:

1. Parsing the interpreter and arguments
1. Splitting the interpreter and arguments
1. Updating the command line arguments


## Parsing the Interpreter & Arguments

At this point the function knows it's a script, so now it has to extract the interpreter and any arguments out of the 128 byte buffer. I've commented each line of this processes below:

```c
//Add a NUL to the end so the string is NUL terminated.
bprm->buf[BINPRM_BUF_SIZE - 1] = '\0';

//The end of the string is either:
// a) A newline character, or
// b) The end of the buffer
	if ((cp = strchr(bprm->buf, '\n')) == NULL)
		cp = bprm->buf+BINPRM_BUF_SIZE-1;
		
	//For a) above, replaces the newline with a NUL.
	//If it was b) above, it redundantly replaces a NUL
	//with another NUL
	*cp = '\0';
	
	//Work our way backwards through the buffer
	while (cp > bprm->buf) {
		cp--;
		//If the character is whitespace, replace it with
		//a NUL
		if ((*cp == ' ') || (*cp == '\t'))
			*cp = '\0';
		//Otherwise, we've found the end of the interpreter
		//string
		else
			break;
	}
	

    //After the hashbang (the buf + 2), remove any whitespace
	for (cp = bprm->buf+2; (*cp == ' ') || (*cp == '\t'); cp++);
	//If we hit a NUL, the line only contains a hashbang
	//with no interpreter
	if (*cp == '\0')
		return -ENOEXEC; /* No interpreter name found */
	//i_name (and cp) points to the start of the interpreter string
	i_name = cp;
```

At the end of this process, `i_name` points to the first character of a NUL terminated string containing the path to the interpreter and arguments, with whitespace before and after being removed.

```
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+----+
| / | u | s | r | / | b | i | n | / | e | n | v |   | p | e | r | l | \0 |
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+----+
  ^
  |
+------+
|i_name|         
+------+ 
```

## Splitting the Interpreter and Arguments

The string now needs to be split into its components: the path to the interpreter, and any arguments to that interpreter:

```c
i_arg = NULL;
//cp still points to the start of the interpreter string,
//exlcluding any whitespace.
//
//Move along the string until we either hit
// a) A NUL character, or
// b) A space or a tab
for ( ; *cp && (*cp != ' ') && (*cp != '\t'); cp++)
    /* nothing */ ;
//If there is whitespace, replace it with a NUL character
while ((*cp == ' ') || (*cp == '\t'))
    *cp++ = '\0';
//If there are bytes after the whitespace, these become
//the arguments to the interpreter.
if (*cp)
    i_arg = cp;
```

Again, taking our example script, the pointers now point to the following pieces of memory:

```
+---+---+---+---+---+---+---+---+---+---+---+---+----+---+---+---+---+----+
| / | u | s | r | / | b | i | n | / | e | n | v | \0 | p | e | r | l | \0 |
+---+---+---+---+---+---+---+---+---+---+---+---+----+---+---+---+---+----+
  ^                                                    ^
  |                                                    |
+------+                                             +-----+
|i_name|                                             |i_arg|          
+------+                                             +-----+
```

One of the main implications of this code is that you cannot have whitespace in the interpreter path, as anything after the whitespace is considered arguments to the interpreter.

## Updating the Bprm

We now know the path to the interpreter, and any arguments that need to be passed to it. 

```c
	retval = remove_arg_zero(bprm);
	if (retval)
		return retval;
	retval = copy_strings_kernel(1, &bprm->interp, bprm);
	if (retval < 0)
		return retval;
	bprm->argc++;
	if (i_arg) {
		retval = copy_strings_kernel(1, &i_arg, bprm);
		if (retval < 0)
			return retval;
		bprm->argc++;
	}
	retval = copy_strings_kernel(1, &i_name, bprm);
	if (retval)
		return retval;
	bprm->argc++;
	retval = bprm_change_interp(i_name, bprm);
	if (retval < 0)
		return retval;
```

```c
file = open_exec(i_name);
	if (IS_ERR(file))
		return PTR_ERR(file);

	bprm->file = file;
	retval = prepare_binprm(bprm);
	if (retval < 0)
		return retval;
	return search_binary_handler(bprm);
```



# Summary






# Appendix - System Calls

It's out of scope to go deep on the system call entry, but at a high level:

- The `syscall` instruction:
    - Saves the address of the following instruction to the `rcx` register
    - Loads a new instruction pointer from the `IA32_LSTAR` model specific register.
    - Jumps to the new instruction at a ring 0 privilege level.
- The `IA32_LSTAR` register holds the address if [entry_SYSCALL_64](https://elixir.bootlin.com/linux/latest/source/arch/x86/entry/entry_64.S#L87)
    - This is set at boot time in [syscall_init()](https://elixir.bootlin.com/linux/latest/source/arch/x86/kernel/cpu/common.c#L1752)
- 