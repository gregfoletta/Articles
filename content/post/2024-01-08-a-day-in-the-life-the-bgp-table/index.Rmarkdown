---
title: 'A Day in the Life: The BGP Table'
author: Greg Foletta
date: '2024-11-12'
slug: []
categories: [C BGP Networking]
---

Much has been written and a lot of analysis performed on the global BGP table over the years, a significant portion by the inimitable [Geoff Huston](https://bgp.potaroo.net/). However this often focuses on is long term trends, like the growth of the routing table or the adoption of IPv6 , dealing with timeframes of of months or years.

I was interested in what was happening in the short term: what does it look like on the front line for those poor routers connected to the churning, foamy chaos of the interenet, trying their best to adhere to [Postel's Law](https://en.wikipedia.org/wiki/Robustness_principle)? In this article we'll take a look at a day in the life of the global BGP tabale, investigating the intra-day shenanigans with an eye to finding some of the ridiculous things that go on out there.

There's a problem with this: the data set it really interesting. I could go on for hours looking at different aspects of it. That doesn't make for the most compelling of articles, so I've focuesed on three areas:

- The behaviour over the course of the day
- Outlier path attributes
- Noisy neighbours

Let's dive in.

```{r include=FALSE}
library(tidyverse)
library(feasts)
library(tsibble)
library(glue)
library(httr2)
library(gt)
library(tidygraph)
library(ggraph)
library(gganimate)
library(forecast)
library(patchwork)

knitr::opts_chunk$set(
    comment = ''
)

scale_colour_brewer_d <- function(..., palette = "Dark2") {
  scale_colour_brewer(..., palette = palette )
}

scale_fill_brewer_d <- function(..., palette = "Dark2") {
  scale_fill_brewer(..., palette = palette)
}

options(
  ggplot2.discrete.colour = scale_colour_brewer_d,
  ggplot2.discrete.fill = scale_fill_brewer_d
)
    
```


```{r include=FALSE}
# ASN Whois
caida_asn_lookup <- function(asn) {
    asn_info <-
    request("https://api.asrank.caida.org") |>
    req_url_path(glue("/v2/restful/asns/{asn}")) |>
    req_perform() |>
    resp_body_json(simplifyVector = TRUE) 
  
    asn_tbl <- 
    asn_info |> 
      pluck('data', 'asn') |> 
      discard(~is.null(.x)) |> 
      _[c('rank', 'asn', 'asnName', 'source', 'cliqueMember', 'seen', 'longitude', 'latitude', 'organization', 'country')] |> 
      as_tibble() |>
      unnest(c(country, organization)) 
    
    if (is.null(asn_info$data$asn$organization$orgId)) {
        return("")
    }
        
    orgID <- asn_info |> pluck('data', 'asn', 'organization', 'orgId')
   
    org_info <-
    request("https://api.asrank.caida.org") |>
    req_url_path(glue("/restful/organizations/{orgID}")) |>
    req_perform() |>
    resp_body_json(simplifyVector = TRUE) 
   
    org_info |> 
      pluck('data', 'organization', 'orgName') |> 
      as_tibble() |>
      bind_cols(asn_tbl)
}
```
# Let the Yak SHaving Begin

The first step, as always, is to get some data to work with. Because I was interested in pure BGP UPDATEs not the resulting routing table itself, and didn't want to have to parse debug output from a virtual router like bird or frr, I decided to write something myself.

More specifically I went back to a half-finished project and got it into a much more polished, working state. The result is **[bgpsee](https://github.com/gregfoletta/bgpsee)**, a multi-threaded BGP peering tool for the CLI. Once peered with another router, the BGP messages are converted into JSON so you can quickly view their contents, or in the case of this article, analyse what's going on.

Here's a single BGP update from the dataset I collected, with some of the irrelevant fields removed. 

```json
{
  "recv_time": 1704483075,
  "id": 12349,
  "type": "UPDATE",
  "nlri": [ "38.43.124.0/23" ],
  "withdrawn_routes": [],
  "path_attributes": [
    {
      "type": "ORIGIN", "type_code": 1,
      "origin": "IGP"
    },
    {
      "type": "AS_PATH", "type_code": 2,
      "n_as_segments": 1,
      "path_segments": [
        {
          "type": "AS_SEQUENCE",
          "n_as": 6,
          "asns": [ 45270, 4764, 2914, 12956, 27951, 23456 ]
        }
      ]
    },
    {
      "type": "NEXT_HOP", "type_code": 3,
      "next_hop": "61.245.147.114"
    },
    {
      "type": "AS4_PATH", "type_code": 17,
      "n_as_segments": 1,
      "path_segments": [
        {
          "type": "AS_SEQUENCE",
          "n_as": 6,
          "asns": [ 45270,4764, 2914, 12956, 27951, 273013 ]
        }
      ]
    }
  ]
}
```

The dataset was collected between the 6/1/2024 tot he 7/1/2024, and consists of 464,673 BGP UPDATE messages received from a peer (thanks [Andrew Vinton](https://www.linkedin.com/in/andrew-vinton/)) with a full BGP table.


```{r eval=FALSE, include=FALSE}
# We read from the RDS file now
#library(tictoc)
#tic("Start BGP load")
#library(jsonlite)
#bgp <- fromJSON('data/full_table_5_transform_day.zip')
#toc("End BGP load")
```


```{r include=FALSE}
# This reads in our RDS file.
 bgp <- read_rds('data/full_table.rds.gz')
```

```{r warning=FALSE, include=FALSE}
# This section cleans and adds some columns
bgp <-
    bgp %>%  
    mutate(
        recv_time = as.POSIXct(recv_time),
        # bgpsee wasn't parsing IPv6 at the time, but we could see the NLRI path attribute
        ip_version = map_chr(path_attributes, ~{ if_else(any(.x$type == "MP_REACH_NLRI" | .x$type == "MP_UNREACH_NLRI"), 'v6', 'v4') }),
        # Is this an update with purely withdrawn routes?
        pure_withdraw = 
            ( map_lgl(withdrawn_routes, ~{ length(.x) > 0 }) & map_lgl(nlri, ~{ length(.x) == 0 }) ) | 
            ( map_lgl(path_attributes, ~{ any(.x$type == "MP_UNREACH_NLRI") & !any(.x$type == "MP_REACH_NLRI") }) ),
        # Number of routes in the update 
        n_routes = map_int(nlri, ~length(.x)),
        address_space = map_dbl(nlri, ~{ 
            n <- .x |> str_extract("/(\\d+)", group = TRUE) |> as.integer()
            2^(32 - n) |> sum() |> log2()
        })
    ) %>% 
    # For each IPv4/IPv6, is this in the inistal send period where we get the big chunk of updates?
    group_by(ip_version) %>% 
    mutate(initial_send = recv_time - first(recv_time) < 30) %>% 
    ungroup()
```

The JSON has been transformed into a semi-rectangular format, with one row for each UPDATE:

```{r echo=FALSE}
# This creates a table which shows each message and the NLRI (adv/withdrawn)
bgp |>
    filter(!initial_send) |> 
    head() |> 
    select(-c(ip_version, pure_withdraw, n_routes, address_space, initial_send)) |> 
    mutate(
        nlri = map_chr(nlri, ~paste0(.x, collapse = "\n")),
        withdrawn_routes = map_chr(withdrawn_routes, ~paste0(.x, collapse = ", "))
    ) |>
    gt() |>
    opt_interactive()
```

The path attributes are nested within each row, and they look like this:

```{r echo=FALSE}
# Here we take a sample of some of of the updates and show the path attributes associated with them.
bgp |>
    # Found an ID with lots of attributes
    filter(id == 695) |> 
    select(id, path_attributes) |>
    unnest(path_attributes) |>
    mutate(
        flags = map_chr(flags, ~paste(.x, collapse = ', '))
    ) |> 
    select(-c(flags_low_nibble, n_as_segments, n_total_as)) |> 
    mutate(
        path_segments = map_chr(path_segments, ~{ paste( c(.x$type, .x$asns), collapse = ' ') })
    ) |>
    mutate(aggregator_asn = as.character(aggregator_asn)) |>
    pivot_longer(c(origin, path_segments, next_hop, aggregator_asn, aggregator_ip)) |> 
    select(-name) |> 
    filter(!(is.na(value) | value == "")) |> 
    gt() |>
    opt_interactive()
```


```{r include=FALSE}
# This pulls the as path up into the top level as a column, and also adds the 'originating_asn' 
# as a column
 bgp <-
    bgp |> 
    unnest(path_attributes, names_sep = '.') |> 
    # Get AS4_PATH if it exists, otherwise get AS_PATH
    filter(path_attributes.type %in% c('AS_PATH', 'AS4_PATH')) |>
    group_by(id) |>
    slice_tail(n = 1) |>
    ungroup() |> 
    select(id, path_attributes.path_segments) |>
    unnest(path_attributes.path_segments) |>
    unnest(asns) |>
    # Concatenate the al path segments into one list 
    group_by(id) |>
    summarise(as_path = list(asns)) |> 
    ungroup() |> 
    # Joint back with original tibble
    right_join(bgp, by = 'id') |> 
    # Pull out the last (originating) AS as a separate column
    mutate(
        originating_asn = map_int(as_path, ~{ 
            if (is.null(.x)) { return(NA_integer_) }
            n = length(.x)
            .x[[n]] 
        }),
        as_path_len = map_int(as_path, ~length(.x))
    )
```

With a better understanding of the source and the structure of the data, let's take a look at what actually goes on.

# Initial Send, Number of v4 and v6 Paths

When you first bring up a BGP peering with a router you get a large amount of UPDATEs consisting of all paths and associated network layer reachability information (NLRI, or more simply 'routes') in the router's BGP table. From this point onwards you will only receive UPDATEs for paths that have changed, or withdrawn routes which no longer have any paths. There's no structural difference between the batch and the ongoing UPDATEs, except for the fact you received the first batch in the first 10 or so seconds of the peering coming up.

Here's a breakdown of the number of distinct paths received in that first batch, separated into IPv4 vs IPv6:

```{r echo=FALSE}
bgp |> 
    filter(initial_send) |> 
    group_by(ip_version) |> 
    count(recv_time) |>
    summarise(paths = sum(n)) |>
    ggplot() +
    geom_col(aes(ip_version, paths, fill = ip_version)) +
    labs(
        title = 'Initial Send of BGP Paths',
        subtitle = 'IPv4 and IPv6',
        fill = 'IP Version',
        x = 'IP Version',
        y = 'Paths'
    ) +
    scale_y_continuous(labels = scales::comma)
```
It's important to highlight that this is a count of BGP paths, **not** routes. Each path is a unique comvbination of path attributes with associated NLRI information attached, and each one sent in a distinct BGP UPDATE message. Each one could have one or one-thousand routes associated with it. Doing the math on this dataset, the total number of routes across all of these paths is `r bgp |> filter(initial_send & ip_version == 'v4') |> select(id, n_routes) |> summarise(routes = sum(n_routes))`. Cross referencing across  [Geoff's data](https://bgp.potaroo.net/as2.0/bgp-active.txt) for the same period, his shows 942,594. We're in the same ballpark.

# A Garden Host or a Fire Hose?

That's enough of the first tranche, let's see how much change there is across the day. The animation below shows the number of BGP UPDATEs received every 30 seconds, along with the mean and median statistics:

```{r echo=FALSE}

{ bgp |> 
    filter(!initial_send) |> 
    group_by(ip_version) |> 
    count(recv_time = floor_date(recv_time, unit = '30 seconds')) |>
    mutate(
        mean_n = mean(n),
        median_n = median(n)
    ) |> 
    ungroup() |> 
    ggplot(aes(recv_time, n)) +
    geom_line(size = .3) +
    facet_grid(vars(ip_version)) +
    transition_reveal(recv_time) +  
    scale_x_datetime() +
    coord_cartesian(clip = 'off') +
    labs(
      title = "BGP v4 Path Advertisements Over Time",
      subtitle = "Time: {floor_date(frame_along, '30 seconds')}",
      x = "Time",
      y = "Number of Paths Advertised",
      colour = "Statistic"
    ) } |> animate(renderer = gifski_renderer(), nframes = 2869, fps = 80) 
```
So on average you're looking at around ~50 path changes on the internet every 30 seconds. This isn't a great representaton of global routing table change, as each one of those UPDATEs could have any number of routes,


```{r echo=FALSE}
ip_space_time <-
    bgp |> 
    filter(!initial_send & ip_version == 'v4') |> 
    unnest(nlri) |>
    separate(nlri, into = c('network', 'subnet'), sep = '/') |>
    select(id, recv_time, subnet) |>
    mutate(subnet = as.integer(subnet)) |>
    group_by(recv_time = floor_date(recv_time, unit = '30 seconds')) |>
    summarise( ip_space = 2^(32 - subnet) |> sum() |> log2() ) |> 
    ggplot() +
    geom_line(aes(recv_time, ip_space), size = .1) +
    labs(
        x = "Time",
        y = "Log2(IP Space)"
    )

ip_space_distribution <-
    bgp |> 
    filter(!initial_send & ip_version == 'v4') |> 
    unnest(nlri) |>
    separate(nlri, into = c('network', 'subnet'), sep = '/') |>
    select(id, recv_time, subnet) |>
    mutate(subnet = as.integer(subnet)) |>
    group_by(recv_time = floor_date(recv_time, unit = '30 seconds')) |>
    summarise( ip_space = 2^(32 - subnet) |> sum() |> log2() ) |> 
    ggplot() +
    geom_histogram(aes(ip_space), binwidth = .1) +
    labs(
        x = "Log2(IP Space)",
        y = "Count"
    )

# Combine with patchwork
(ip_space_time / ip_space_distribution) +
    plot_annotation(
        title = 'Log2(IPSpace) - Aggregate Updates over Time and Distribution'
    )
```


```{r echo=FALSE}
bgp |>
    filter(!initial_send) |> 
    group_by(ip_version) |> 
    count(recv_time = floor_date(recv_time, unit = '1 minutes')) |>
    ungroup() |>
    filter(ip_version == 'v4') |>
    as_tsibble(index = recv_time, key = ip_version) |>
    ggAcf(lag.max = 60) +
    labs(
        title = 'BGP UPDATE Counts - ACF Plot (Correlogram)',
        subtitle = 'One Minute Lags'
    )
```

```{r echo=FALSE}
bgp |>
    filter(!initial_send) |> 
    group_by(ip_version) |> 
    count(recv_time = floor_date(recv_time, unit = '1 minutes')) |>
    ungroup() |>
    pivot_wider(names_from = ip_version, values_from = n) |>
    as_tsibble(index = recv_time) |>
    gg_lag(v4, geom = 'point', period = 1, lags = 38:43)
```



```{r echo=FALSE}
bgp |> 
    filter(!initial_send) |> 
    group_by(ip_version) |> 
    count(recv_time = floor_date(recv_time, unit = '5 minutes')) |>
    ungroup() |> 
    ggplot() +
    geom_histogram(aes(n, fill = ip_version), binwidth = 20) +
    labs(
        title = 'Foo'
    ) +
    guides(colour = 'none')
```
```{r echo=FALSE, message=FALSE, warning=FALSE}
bgp |> 
    filter(!initial_send & ip_version == 'v4') |>
    add_count(recv_time = floor_date(recv_time, unit = '5 minutes')) |>
    slice_max(order_by = n, n = 1) |>
    unnest(asn = as_path) |>
    count(asn, sort = TRUE) |>
    slice_head(n = 10) |>
    mutate(as_info = map(asn, ~caida_asn_lookup(.x))) |>
    select(n, as_info) |>
    unnest(as_info) |>
    select(n, organisation = value, asn, source, country) |>  
    gt() |>  
    opt_interactive()
```

# Prepending Madness

There's a couple of path attributes you can use to modify how traffic flows within an autonomous system: MED for neighbours, 


```{r echo=FALSE}
bgp |>
    group_by(ip_version) |> 
    slice_max(order_by = as_path_len, n = 50, with_ties = FALSE) |>
    mutate(order = row_number()) |>
    ungroup() |> 
    ggplot() +
    geom_col(aes(order, as_path_len, fill = ip_version)) +
    facet_grid(vars(ip_version)) 
```
```{r echo=FALSE}
bgp |>
    filter(ip_version == 'v4') |>
    slice_max(order_by = as_path_len, n = 1) |>
    pluck('as_path', 1) |>
    paste(collapse = ' ')
```

Someone at asn 45270, 'Dinas Komunikasi dan Informatika Kabupaten Tulungagung' out of Indonesia, really wanted the NLRI '103.179.250.0/24' to be less preferable. 

```{r}
bgp |>
    filter(ip_version == 'v4') |>
    unnest(nlri) |>
    filter(nlri == '103.179.250.0/24') |>
    slice_tail() |> 
    select(id, as_path, recv_time, type, nlri) |>
    gt() |>
    opt_interactive()
```


```{r echo=FALSE}
bgp |>
    filter(ip_version == 'v6') |>
    slice_max(order_by = as_path_len, n = 1) |>
    pluck('as_path', 1) |>
    paste(collapse = ' ')
```

This time we've got what appears to be transit provider asn8772 (NetAssist LLC), prepending to make paths to asn203868 (Rifqi Arief Pamungkas, again out of Indonesia)

# Path Attributes

```{r include=FALSE}
bgpv4_attr <-
    bgp |>
    filter(ip_version == 'v4') |> 
    unnest(path_attributes, names_sep = '.')
```


```{r echo=FALSE}
bgpv4_attr |>
    #filter(!path_attributes.type_code %in% c(1,2,3)) |>
    mutate(pa = glue('{path_attributes.type} ({path_attributes.type_code})')) |>
    count(pa) |>
    mutate(pa = fct_reorder(pa, n)) |> 
    ggplot() +
    geom_col(aes(pa, log(n), fill = 'red')) +
    geom_label(aes(pa, log(n), label = n), nudge_y = -.2) +
    coord_flip() +
    scale_fill_discrete(guide = 'none') + 
    labs(
        title = 'Foo'
    )
```
```{r echo=FALSE}
 bgpv4_attr |>
    filter(path_attributes.type_code == 255) |>
    distinct(originating_asn) |>
    mutate(organisation = map_df(originating_asn, ~caida_asn_lookup(.x))) |>
    unnest(organisation) |>
    select(originating_asn, organisation = value, source, country) |> 
    gt() 
```

# Flippy-Flappy: Who's Having a Bad Time?

```{r echo=FALSE}
bgp |>
    unnest(nlri) |>
    count(nlri) |>
    slice_max(n, n = 50) |>
    gt() |> 
    opt_interactive()
```


```{r echo=FALSE}
bind_rows(
    bgp |> unnest(withdrawn_routes) |> filter(withdrawn_routes == '140.99.244.0/23') |> select(-nlri),
    bgp |> unnest(nlri) |> filter(nlri == '140.99.244.0/23') |> select(-withdrawn_routes)
) |> select(id, recv_time, withdrawn_routes, nlri) |>
    mutate(type = if_else(is.na(withdrawn_routes), 'UPDATE', 'WITHDRAW')) |>
    select(id, recv_time, type) |>
    group_by(type) |>
    mutate(n = row_number()) |>
    ungroup() |>
    ggplot() +
    geom_point(aes(recv_time, n, colour = type), size = .5) +
    facet_grid(vars(type), scales = 'free_y')
```

```{r include=FALSE}
as_path_graph <- function(as_path) {
    g <- tibble(from = NA, to = NA)
    path_length <- length(as_path)
    if (path_length < 2) {
        return(NA)
    }
    
    for (x in length(as_path):2) {
        g <- g |> add_row(from = as_path[[x]], to = as_path[[x - 1]]) 
    }
    
    return(g |> filter(!is.na(from)))
}

as_path_edges <- bgp |> 
    unnest(nlri) |> 
    filter(nlri == '140.99.244.0/23') |>
    select(id, as_path) |>
    mutate(graph = map(as_path, ~as_path_graph(.x))) |>
    select(-c(as_path, id)) |> 
    unnest(graph) |>
    count(from, to) |>
    mutate(
        from = as.character(from),
        to = as.character(to)
    )
```

```{r message=FALSE, warning=FALSE}
as_tbl_graph(as_path_edges, directed = TRUE) |>
    ggraph(layout = 'igraph', algorithm = 'fr') +
    geom_edge_link(arrow = arrow(type = 'closed', length = unit(4, 'mm')), end_cap = circle(7, 'mm')) +
    geom_node_point(size = 17) +
    geom_node_text(aes(label = name), colour = 'white') +
    guides(edge_width = FALSE) +
    theme_graph()
```

