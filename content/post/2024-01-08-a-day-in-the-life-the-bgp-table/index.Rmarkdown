---
title: 'A Day in the Life: The BGP Table'
author: Greg Foletta
date: '2024-01-08'
slug: []
categories: []
tags: []
images: []
---
```{r include=FALSE}
library(tidyverse)
library(feasts)
library(tsibble)
library(glue)
library(httr2)
library(gt)
library(tidygraph)
library(ggraph)
library(gganimate)
```


```{r}
# ASN Whois
caida_asn_lookup <- function(asn) {
    asn_info <-
    request("https://api.asrank.caida.org") |>
    req_url_path(glue("/v2/restful/asns/{asn}")) |>
    req_perform() |>
    resp_body_json(simplifyVector = TRUE) 
  
    asn_tbl <- 
    asn_info |> 
      pluck('data', 'asn') |> 
      discard(~is.null(.x)) |> 
      _[c('rank', 'asn', 'asnName', 'source', 'cliqueMember', 'seen', 'longitude', 'latitude', 'organization', 'country')] |> 
      as_tibble() |>
      unnest(c(country, organization)) 
    
    if (is.null(asn_info$data$asn$organization$orgId)) {
        return("")
    }
        
    orgID <- asn_info |> pluck('data', 'asn', 'organization', 'orgId')
   
    org_info <-
    request("https://api.asrank.caida.org") |>
    req_url_path(glue("/restful/organizations/{orgID}")) |>
    req_perform() |>
    resp_body_json(simplifyVector = TRUE) 
   
    org_info |> 
      pluck('data', 'organization', 'orgName') |> 
      as_tibble() |>
      bind_cols(asn_tbl)
}
```
# Let the Yak SHaving Begin


# Updates, Not Routes

```json
{
  "recv_time": 1704483075,
  "id": 12349,
  "type": "UPDATE",
  "nlri": [ "38.43.124.0/23" ],
  "withdrawn_routes": [],
  "path_attributes": [
    {
      "type": "ORIGIN", "type_code": 1,
      "flags": [ well-known", "transitive", "complete", "standard" ],
      "origin": "IGP"
    },
    {
      "type": "AS_PATH", "type_code": 2,
      "flags": ["well-known", "transitive", "complete", "standard"],
      "n_as_segments": 1,
      "path_segments": [
        {
          "type": "AS_SEQUENCE",
          "n_as": 6,
          "asns": [ 45270, 4764, 2914, 12956, 27951, 23456 ]
        }
      ]
    },
    {
      "type": "NEXT_HOP", "type_code": 3,
      "flags": ["well-known", "transitive", "complete", "standard"],
      "next_hop": "61.245.147.114"
    },
    {
      "type": "AS4_PATH", "type_code": 17,
      "flags": ["optional", "non-transitive","partial","extended" ],
      "n_as_segments": 1,
      "path_segments": [
        {
          "type": "AS_SEQUENCE",
          "n_as": 6,
          "asns": [ 45270,4764, 2914, 12956, 27951, 273013 ]
        }
      ]
    }
  ]
}
```


```{r}
#library(tictoc)
#tic("Start BGP load")
library(jsonlite)
bgp <- fromJSON('data/full_table_5_transform_day.zip')
#toc("End BGP load")
```


```{r cars}
foo <- read_rds('~/Documents/Projects/articles.foletta.org/content/post/2024-01-08-a-day-in-the-life-the-bgp-table/data/full_table.rds')

foo |>
  mutate(
        recv_time = as.POSIXct(recv_time),
        ip_version = map_chr(path_attributes, ~{ if_else(any(.x$type == "MP_REACH_NLRI" | .x$type == "MP_UNREACH_NLRI"), 'v6', 'v4') })
  )
```

```{r}
 bgp <- read_rds('data/full_table.rds')
```

```{r}
bgp <-
    bgp %>%  
    mutate(
        recv_time = as.POSIXct(recv_time),
        ip_version = map_chr(path_attributes, ~{ if_else(any(.x$type == "MP_REACH_NLRI" | .x$type == "MP_UNREACH_NLRI"), 'v6', 'v4') }),
        pure_withdraw = 
            ( map_lgl(withdrawn_routes, ~{ length(.x) > 0 }) & map_lgl(nlri, ~{ length(.x) == 0 }) ) | 
            ( map_lgl(path_attributes, ~{ any(.x$type == "MP_UNREACH_NLRI") & !any(.x$type == "MP_REACH_NLRI") }) ),
        n_routes = map_int(nlri, ~length(.x)),
        address_space = map_dbl(nlri, ~{ 
            n <- .x |> str_extract("/(\\d+)", group = TRUE) |> as.integer()
            2^(32 - n) |> sum() |> log2()
        })
    ) %>% 
    group_by(ip_version) %>% 
    mutate(initial_send = recv_time - first(recv_time) < 30) %>% 
    ungroup()
```

```{r}
 bgp <-
    bgp |> 
    unnest(path_attributes, names_sep = '.') |> 
    filter(path_attributes.type %in% c('AS_PATH', 'AS4_PATH')) |>
    # Get AS4_PATH if it exists, otherwise get AS_PATH
    group_by(id) |>
    slice_tail(n = 1) |>
    ungroup() |> 
    select(id, path_attributes.path_segments) |>
    unnest(path_attributes.path_segments) |>
    unnest(asns) |>
    # Concatenate the al path segments into one list 
    group_by(id) |>
    summarise(as_path = list(asns)) |> 
    ungroup() |> 
    # Joint back with original tibble
    right_join(bgp, by = 'id') |> 
    # Pull out the last (originating) AS as a separate column
    mutate(
        originating_asn = map_int(as_path, ~{ 
            if (is.null(.x)) { return(NA_integer_) }
            n = length(.x)
            .x[[n]] 
        }),
        as_path_len = map_int(as_path, ~length(.x))
    )
```

# Initial Graph

```{r}
#bgp_asn_paths <- 
#  bgp |> 
#  filter(
#    (as_path_len > 2 & as_path_len < median(as_path_len)) & address_space > 16
#  )

#bgp_asn_paths <-
#  bgp_asn_paths |> 
#  group_by(originating_asn) |>
#  summarise(originating_ip_space = log2(sum(2^address_space))) |>
#  right_join(bgp_asn_paths)


bgp_graph <-
  bgp |>
  filter(initial_send & !pure_withdraw & ip_version == 'v4' & as_path_len > 1) |> 
  select(as_path, address_space) |>
  mutate(as_path_string = map_chr(as_path, ~{ paste0(.x, collapse = ',') })) |> 
  distinct(as_path_string, .keep_all = TRUE) |>
  # Build the pairwise asns into from,to. Remove the last node so we're only looking at 
  # transit ASes. Otherwise the graph becomes unplottable with leaf ASNs very quickly
  mutate(edges = map(as_path, ~{ tibble(from = .x[ 1:(length(.x) - 2) ], to =  .x[ 2:(length(.x) - 1) ]) } )) |>
  select(edges, address_space) |> 
  unnest(edges) |>
  distinct(from, to, .keep_all = TRUE) |>
  as_tbl_graph()
  #mutate(org_name = map_chr(name, ~caida_asn_lookup(.x)))
```

```{r}
foo <-
bgp_graph |>
  activate(nodes) |>
  mutate(node_type = if_else(name == "4764", "Root", "Upstream")) |> 
  mutate(centrality = centrality_betweenness()) |>
  ggraph(layout = 'auto') +
  geom_edge_fan() +
  geom_point_interactive(aes(x = 1, y = 1)) +
  geom_node_point(aes(size = centrality, colour = node_type)) +
  labs(
    title = "Local ASN Region",
    subtitle = "Path Length < Median, Originating IP Space > log2(16)",
    colour = "Node Type",
    size = "Node Centrality"
  )

foo

#girafe(foo, options = list(opts_sizing(rescale = FALSE)))
```


# Initial Send, Number of v4 and v6 Paths

```{r}
bgp |> 
    filter(initial_send) |> 
    group_by(ip_version) |> 
    count(recv_time) |>
    summarise(paths = sum(n)) |>
    ggplot() +
    geom_col(aes(ip_version, paths, fill = ip_version)) +
    labs(
        title = 'Initial Send of BGP Paths',
        subtitle = 'IPv4 and IPv6',
        fill = 'IP Version',
        x = 'IP Version',
        y = 'Paths'
    ) 
```
# Updated Over Time


```{r message=FALSE, warning=FALSE}
{ bgp |> 
  filter(!initial_send & ip_version == 'v4') |> 
  count(recv_time = floor_date(recv_time, unit = '30 minutes', )) |>
  mutate(mean_n = mean(n)) |> 
  ggplot(aes(recv_time, n, group = 1)) +
  geom_line(aes(recv_time, n)) +
  geom_hline(aes(yintercept = mean_n), linetype = 2) +
  geom_segment(aes(xend = max(recv_time), yend = n), linetype = 2, colour = 'grey') +
  geom_label(aes(x = max(recv_time) + hms("1:0:0"), label = n)) +
  geom_point() +
  transition_reveal(recv_time) +
  scale_x_datetime() +
  coord_cartesian(clip = 'off') +
  labs(
    title = "BGP Path Advertisements Over Time",
    subtitle = "Dashed Line: Mean, Time: {floor_date(frame_along)}",
    x = "Time",
    y = "Number of Paths Advertised"
  ) } |>
  animate(duration = 49, fps = 1)
```

# Longest AS_PATHS

```{r}
bgp |>
    group_by(ip_version) |> 
    slice_max(order_by = as_path_len, n = 10) |>
    mutate(order = row_number()) |>
    ungroup() |> 
    ggplot() +
    geom_col(aes(order, as_path_len, fill = ip_version)) +
    facet_wrap(~ip_version, scales = 'free') +
    scale_x_discrete() 
```



```{r}
bgp |>
    filter(ip_version == 'v6') |>
    slice_max(as_path_len, n = 1) |>
    select(as_path) |>
    unnest(as_path) |>
    add_count(as_path) |>
    distinct(as_path, .keep_all = TRUE) |>
    mutate(organisation = map_df(as_path, ~caida_asn_lookup(.x))) |>
    gt() |>
    cols_label(
        as_path = md("**AS Number**"),
        n = md("**No. of Prepends**"),
        organisation = md("**Organisation Name**"),
    ) |> 
    cols_align('center')
```

# IP Address Space

```{r}
bgpv4 <- bgp |> filter(ip_version == 'v4')
```


## Prefix Length Distribution

```{r}
bgpv4 |>
    filter(initial_send) |>
    unnest(nlri) |>
    # Remove default
    filter(nlri != '0.0.0.0/0') |> 
    separate(nlri, into = c('prefix', 'prefix_len'), sep = '/') |>
    count(prefix_len) |>
    mutate(prefix_len = fct_reorder(prefix_len, n)) |> 
    ggplot() +
    geom_col(aes(prefix_len, n))
```
```{r}

```

# Path Attributes

```{r}
bgpv4_attr <-
    bgpv4 |>
    unnest(path_attributes, names_sep = '.')
```


```{r}
bgpv4_attr |>
    filter(!path_attributes.type_code %in% c(1,2,3)) |>
    mutate(pa = glue('{path_attributes.type} ({path_attributes.type_code})')) |>
    count(pa) |>
    mutate(pa = fct_reorder(pa, n)) |> 
    ggplot() +
    geom_col(aes(pa, log(n))) +
    geom_label(aes(pa, log(n), label = n), nudge_y = -.2) +
    coord_flip()
```
```{r}
 bgpv4_attr |>
    filter(path_attributes.type_code == 21) |>
    distinct(originating_asn) |>
    mutate(organisation = map_df(originating_asn, ~caida_asn_lookup(.x))) |>
    unnest(organisation)
```


