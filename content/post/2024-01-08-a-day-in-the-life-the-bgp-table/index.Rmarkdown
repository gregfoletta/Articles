---
title: 'A Day in the Life: The BGP Table'
author: Greg Foletta
date: '2024-01-08'
slug: []
categories: []
tags: []
images: []
---
```{r include=FALSE}
library(tidyverse)
library(jsonlite)
library(feasts)
library(tsibble)
library(tictoc)
library(glue)
library(httr2)
library(gt)
library(igraph)
```

```{r setup, echo = F}
knitr::opts_chunk$set(include = FALSE)
```

# Let the Yak SHaving Begin


# Updates, Not Routes

```json
{
  "recv_time": 1704483075,
  "id": 12349,
  "type": "UPDATE",
  "nlri": [ "38.43.124.0/23" ],
  "withdrawn_routes": [],
  "path_attributes": [
    {
      "type": "ORIGIN", "type_code": 1,
      "flags": [ well-known", "transitive", "complete", "standard" ],
      "origin": "IGP"
    },
    {
      "type": "AS_PATH", "type_code": 2,
      "flags": ["well-known", "transitive", "complete", "standard"],
      "n_as_segments": 1,
      "path_segments": [
        {
          "type": "AS_SEQUENCE",
          "n_as": 6,
          "asns": [ 45270, 4764, 2914, 12956, 27951, 23456 ]
        }
      ]
    },
    {
      "type": "NEXT_HOP", "type_code": 3,
      "flags": ["well-known", "transitive", "complete", "standard"],
      "next_hop": "61.245.147.114"
    },
    {
      "type": "AS4_PATH", "type_code": 17,
      "flags": ["optional", "non-transitive","partial","extended" ],
      "n_as_segments": 1,
      "path_segments": [
        {
          "type": "AS_SEQUENCE",
          "n_as": 6,
          "asns": [ 45270,4764, 2914, 12956, 27951, 273013 ]
        }
      ]
    }
  ]
}
```



```{r eval=FALSE, include=FALSE}
tic("Start BGP load")
bgp <-
fromJSON('data/full_table_5_transform_day.zip') |>
    as_tibble() 
toc("End BGP load")
```


```{r}
tic("Load and Cleaning")
bgp <-
    read_rds('data/full_table.rds') |> 
    mutate(
        recv_time = as.POSIXct(recv_time),
        ip_version = map_chr(path_attributes, ~{ if_else(any(.x$type == "MP_REACH_NLRI" | .x$type == "MP_UNREACH_NLRI"), 'v6', 'v4') }),
        pure_withdraw = 
            ( map_lgl(withdrawn_routes, ~{ length(.x) > 0 }) & map_lgl(nlri, ~{ length(.x) == 0 }) ) | 
            ( map_lgl(path_attributes, ~{ any(.x$type == "MP_UNREACH_NLRI") & !any(.x$type == "MP_REACH_NLRI") }) )
    ) |>
    group_by(ip_version) |>
    mutate(initial_send = recv_time - first(recv_time) < 30) |>
    ungroup()
toc()

tic("AS_PATH Variables")
bgp <-
    bgp |> 
    unnest(path_attributes, names_sep = '.') |>
    filter(path_attributes.type %in% c('AS_PATH', 'AS4_PATH')) |>
    # Get AS4_PATH if it exists, otherwise get AS_PATH
    group_by(id) |>
    slice_tail(n = 1) |>
    ungroup() |> 
    select(id, path_attributes.path_segments) |>
    unnest(path_attributes.path_segments) |>
    unnest(asns) |>
    # Concatenate the al path segments into one list 
    group_by(id) |>
    summarise(as_path = list(asns)) |> 
    ungroup() |> 
    # Joint back with original tibble
    right_join(bgp, by = 'id') |> 
    # Pull out the last (originating) AS as a separate column
    mutate(
        originating_asn = map_int(as_path, ~{ 
            if (is.null(.x)) { return(NA_integer_) }
            n = length(.x)
            .x[[n]] 
        }),
        as_path_len = map_int(as_path, ~length(.x))
    )
toc()
```

# Initial Graph

```{r}
bgp_asn_paths <- bgp |> filter(as_path_len < 4 & as_path_len > 2)

bgp_asn_paths |>
    select(as_path) |>
    mutate(as_path_string = map_chr(as_path, ~{ paste0(.x, collapse = ',') })) |> 
    distinct(as_path_string, .keep_all = TRUE) |>
    # Build the pairwise asns into from,to. Remove the last node so we're only looking at 
    # transit ASes. Otherwise the graph becomes unplottable with leaf ASNs very quickly
    mutate(edges = map(as_path, ~{ tibble(from = .x[ 1:(length(.x) - 2) ], to =  .x[ 2:(length(.x) - 1) ]) } )) |>
    unnest(edges) |>
    distinct(from, to) |>
    graph_from_data_frame() |>
    plot()
```



# Initial Send, Number of v4 and v6 Paths

```{r}
bgp |> 
    filter(initial_send) |> 
    group_by(ip_version) |> 
    count(recv_time) |>
    summarise(paths = sum(n)) |>
    ggplot() +
    geom_col(aes(ip_version, paths, fill = ip_version)) +
    labs(
        title = 'Initial Send of BGP Paths',
        subtitle = 'IPv4 and IPv6',
        fill = 'IP Version',
        x = 'IP Version',
        y = 'Paths'
    ) 
```
# Updated Over Time


```{r}
bgp |> 
    filter(!initial_send) |> 
    group_by(ip_version) |>
    count(recv_time) |>
    ggplot() +
    geom_line(aes(recv_time, n, colour = ip_version)) +
    facet_wrap(~ip_version, nrow = 2) +
    scale_x_datetime()
```

# Longest AS_PATHS

```{r}
bgp |>
    group_by(ip_version) |> 
    slice_max(order_by = as_path_len, n = 10) |>
    mutate(order = row_number()) |>
    ungroup() |> 
    ggplot() +
    geom_col(aes(order, as_path_len, fill = ip_version)) +
    facet_wrap(~ip_version, scales = 'free') +
    scale_x_discrete()
```
```{r}
# ASN Whois
caida_asn_lookup <- function(asn) {
    orgID <-
    request("https://api.asrank.caida.org") |>
    req_url_path(glue("/v2/restful/asns/{asn}")) |>
    req_perform() |>
    resp_body_json(simplifyVector = TRUE) 
   
   
    print(asn)
    print(orgID$data$asn$organization$orgId)
    
    if (is.null(orgID$data$asn$organization$orgId)) {
        return("")
    }
        
    orgID <- orgID |> pluck('data', 'asn', 'organization', 'orgId')
    
    request("https://api.asrank.caida.org") |>
    req_url_path(glue("/restful/organizations/{orgID}")) |>
    req_perform() |>
    resp_body_json(simplifyVector = TRUE) |>
    pluck('data', 'organization', 'orgName') 
}
```


```{r}
bgp |>
    filter(ip_version == 'v6') |>
    slice_max(as_path_len, n = 1) |>
    select(as_path) |>
    unnest(as_path) |>
    add_count(as_path) |>
    distinct(as_path, .keep_all = TRUE) |>
    mutate(organisation = map_chr(as_path, ~caida_asn_lookup(.x))) |>
    gt() |>
    cols_label(
        as_path = md("**AS Number**"),
        n = md("**No. of Prepends**"),
        organisation = md("**Organisation Name**"),
    ) |> 
    cols_align('center')
```

# IP Address Space

```{r}
bgpv4 <- bgp |> filter(ip_version == 'v4')
```


## Prefix Length Distribution

```{r}
bgpv4 |>
    filter(initial_send) |>
    unnest(nlri) |>
    # Remove default
    filter(nlri != '0.0.0.0/0') |> 
    separate(nlri, into = c('prefix', 'prefix_len'), sep = '/') |>
    count(prefix_len) |>
    mutate(prefix_len = fct_reorder(prefix_len, n)) |> 
    ggplot() +
    geom_col(aes(prefix_len, n))
```
```{r}

```

# Path Attributes

```{r}
bgpv4_attr <-
    bgpv4 |>
    unnest(path_attributes, names_sep = '.')
```


```{r}
bgpv4_attr |>
    filter(!path_attributes.type_code %in% c(1,2,3)) |>
    mutate(pa = glue('{path_attributes.type} ({path_attributes.type_code})')) |>
    count(pa) |>
    mutate(pa = fct_reorder(pa, n)) |> 
    ggplot() +
    geom_col(aes(pa, log(n))) +
    geom_label(aes(pa, log(n), label = n), nudge_y = -.2) +
    coord_flip()
```
```{r}
 bgpv4_attr |>
    filter(path_attributes.type_code == 21) |>
    distinct(originating_asn) |>
    mutate(organisation = map_chr(originating_asn, ~caida_asn_lookup(.x)))
```


